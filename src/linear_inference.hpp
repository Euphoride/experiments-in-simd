/**
 * @brief   Trying to squeeze out the fastest linear inference I can on this machine.
 *
 * @date    2025-08-05
 * @version 0.1
 *
 * @details
 *  - dummy data is autogenerated for benchmarking purposes, we'll microbenchmark over
 *    a range of uniformly generated parameters for the model to remove data-dependent
 *    artifacts in the benchmark.
 *  - using apple silicon (an M3 specifically) so i'll be using NEON intrinsics rather
 *    than AVX or similar.
 *  - ...
 *
 * @license MIT
 */

#pragma once

#include <cstddef>

namespace simd {

/**
 * @brief   SIMD-enabled logistic classification based on the provided data, weights and biases.
 *
 * @param   data     pointer to input feature array
 * @param   weights  pointer to model weight array
 * @param   length   number of elements in data/weights
 * @param   bias     bias term to add after dot-product
 *
 * @return  float    the computed inference value (e.g. logistic output)
 *
 * @details
 * this computes a dot-product:
 *   sum_i(data[i] * weights[i]) + bias
 * then applies a sigmoid:
 *   1 / (1 + exp(-sum))
 *
 * @note
 * - assumes data and weights are 16-byte aligned
 * - length can be any size; handles tail elements scalar
 * - optimized with arm_neon intrinsics for performance
 */
float logistic_inference_aligned_16_optimised(const float* data, const float* weights,
                                              std::size_t length, float bias);

/**
 * @brief   Naive logistic classification based on the provided data, weights and biases.
 *
 * @param   data     pointer to input feature array
 * @param   weights  pointer to model weight array
 * @param   length   number of elements in data/weights
 * @param   bias     bias term to add after dot-product
 *
 * @return  float    the computed inference value (e.g. logistic output)
 *
 * @details
 * this computes a dot-product:
 *   sum_i(data[i] * weights[i]) + bias
 * then applies a sigmoid:
 *   1 / (1 + exp(-sum))
 *
 * @note
 * - length can be any size; handles tail elements scalar
 * - written using a typical, naive algorithm
 * - data is allowed to be unaligned
 */
float logistic_inference_unaligned_unoptimised(const float* data, const float* weights,
                                               std::size_t length, float bias);
}  // namespace simd
